import{_ as s,c as i,o as e,ag as t}from"./chunks/framework.DRADY2L-.js";const k=JSON.parse('{"title":"Multithreading and Concurrency","description":"","frontmatter":{},"headers":[],"relativePath":"generalProg/threadConcurrency.md","filePath":"generalProg/threadConcurrency.md","lastUpdated":1714596117000}'),n={name:"generalProg/threadConcurrency.md"};function l(h,a,r,p,d,o){return e(),i("div",null,[...a[0]||(a[0]=[t(`<h1 id="multithreading-and-concurrency" tabindex="-1">Multithreading and Concurrency <a class="header-anchor" href="#multithreading-and-concurrency" aria-label="Permalink to &quot;Multithreading and Concurrency&quot;">​</a></h1><h2 id="understanding-multithreading-in-c" tabindex="-1">Understanding Multithreading in C++ <a class="header-anchor" href="#understanding-multithreading-in-c" aria-label="Permalink to &quot;Understanding Multithreading in C++&quot;">​</a></h2><p>Multithreading allows a program to perform multiple tasks concurrently within the same process space. It involves creating multiple threads, with each thread executing part of the program code. In C++, threads are represented by the <code>std::thread</code> class, part of the <code>&lt;thread&gt;</code> header introduced in C++11.</p><h2 id="creating-and-managing-threads" tabindex="-1">Creating and Managing Threads <a class="header-anchor" href="#creating-and-managing-threads" aria-label="Permalink to &quot;Creating and Managing Threads&quot;">​</a></h2><p><strong>Creating a Thread:</strong> To create a thread, instantiate an std::thread object and pass the function to be executed by the thread as an argument.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> task1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // Task code here </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">thread</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> t1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">task1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Creates a thread executing task1</span></span></code></pre></div><p><strong>Joining Threads:</strong> To ensure a thread has completed execution before continuing, use the join() method. Joining a thread blocks the calling thread until the thread represented by the std::thread object completes.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Main thread waits for t1 to finish</span></span></code></pre></div><p><strong>Detaching Threads:</strong> Threads can also be detached, allowing them to run independently from the main thread. A detached thread releases its resources automatically upon completion.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">detach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // t1 will run independently</span></span></code></pre></div><h2 id="concurrency-vs-parallelism" tabindex="-1">Concurrency vs. Parallelism <a class="header-anchor" href="#concurrency-vs-parallelism" aria-label="Permalink to &quot;Concurrency vs. Parallelism&quot;">​</a></h2><p>While often used interchangeably, concurrency and parallelism have distinct meanings in the context of programming. Concurrency refers to the ability of a program to deal with multiple tasks at once, which might not necessarily be executing simultaneously. Parallelism, on the other hand, involves performing multiple operations truly in parallel, leveraging multi-core processors.</p><h3 id="synchronization-and-data-safety" tabindex="-1">Synchronization and Data Safety <a class="header-anchor" href="#synchronization-and-data-safety" aria-label="Permalink to &quot;Synchronization and Data Safety&quot;">​</a></h3><p>Managing access to shared data is a critical aspect of multithreaded programming to prevent data races and ensure thread safety.</p><p><strong>Mutexes:</strong> Mutexes (mutual exclusions) are used to protect shared data by ensuring that only one thread can access the data at a time.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::mutex mtx;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mtx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Lock the mutex</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Critical section</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mtx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Unlock the mutex</span></span></code></pre></div><p><strong>Lock Guards:</strong> C++ introduces std::lock_guard, a scope-based mutex locker, ensuring that a mutex is properly released when the control leaves the scope, thus preventing deadlocks.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::lock_guard</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::mutex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> guard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mtx);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // Critical section </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Mutex is automatically released here</span></span></code></pre></div>`,18)])])}const g=s(n,[["render",l]]);export{k as __pageData,g as default};
